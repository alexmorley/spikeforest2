#!/usr/bin/env python

import spikeforest_batch_run as sbr
import spikeforest as sf
import os
import sys
import argparse
import json

import batcho

def main():
  parser = argparse.ArgumentParser(description = 'Run a batch command (prepare, run, assemble, status, results)')
  parser.add_argument('command', help='set, prepare, run, assemble, status, results')
  parser.add_argument('batch_name', help='The name of the batch')
  parser.add_argument('--mlpr_force_run', help='Whether to force run the MountainLab processors',action="store_true")
  parser.add_argument('--job_index', help='Only prepare and run one job and do not assemble',default='')
  parser.add_argument('--clear', help='Applies only to prepare command',action='store_true')
  parser.add_argument('--input',help='Applies to set command',default='')
  parser.add_argument('--output',help='Applies to results command',default='')

  args = parser.parse_args()

  if args.mlpr_force_run:
    os.environ['MLPROCESSORS_FORCE_RUN']='TRUE'

  if args.clear:
    if args.command != 'prepare':
      print('--clear cannot be used with command other than prepare')
      sys.exit(-1)

  if args.output:
    if args.command != 'results':
      print('--output cannot be used with command other than results')
      sys.exit(-1)    

  if args.input:
    if args.command != 'set':
      print('--output cannot be used with command other than set')
      sys.exit(-1)    

  if args.job_index:
    if args.command not in ['prepare','run','status']:
      print('Invalid option for this command: --job_index')
      sys.exit(-1)
    job_index=int(args.job_index)
  else:
    job_index=None


  if args.command in ['set','prepare','run','assemble']:
    spikeforest_password=os.environ.get('SPIKEFOREST_PASSWORD',None)
    if not spikeforest_password:
      print('Environment variable not set: SPIKEFOREST_PASSWORD')
      sys.exit(-1)
    sf.kbucketConfigRemote(name='spikeforest1-readwrite',password=spikeforest_password)
  else:
    sf.kbucketConfigRemote(name='spikeforest1-readonly')

  sbr.register_job_commands()

  # This can be important for some of the jobs in certain situations
  os.environ['DISPLAY']=''

  if args.command=='set':
    if not args.input:
      print('Missing --input argument.')
      sys.exit(-1)
    obj=_read_json_file(args.input)
    batcho.set_batch(batch_name=args.batch_name,jobs=obj['jobs'])
  elif args.command=='prepare':
    batcho.prepare_batch(batch_name=args.batch_name,clear_jobs=args.clear,job_index=job_index)
  elif args.command=='run':
    batcho.run_batch(batch_name=args.batch_name,job_index=job_index)
  elif args.command=='assemble':
    batcho.assemble_batch(batch_name=args.batch_name)
  elif args.command=='status':
    statuses=batcho.get_batch_job_statuses(batch_name=args.batch_name,job_index=job_index)
    print_job_statuses(statuses)
  elif args.command=='results':
    if not args.output:
      print('Missing --output argument.')
      sys.exit(-1)
    results=batcho.get_batch_results(batch_name=args.batch_name)
    _write_json_file(results,args.output)
  else:
    print('Invalid command: '+args.command)
    sys.exit(-1)

def print_job_statuses(statuses):
  for status in statuses:
    print('{}: {}'.format(status['job']['label'],status['status']))

def _write_json_file(obj,path):
  with open(path,'w') as f:
    return json.dump(obj,f)

def _read_json_file(path):
  with open(path) as f:
    return json.load(f)

if __name__== "__main__":
  main()
